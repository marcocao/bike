Course Overview
Hey, this is Dan Bunker and welcome to Building Your First App with Spring Boot in Angular. I'm a software developer and consultant based in the Salt Lake City, Utah area. Spring Boot with the Spring Ecosystem has become a top pick for many organizations and developers when it comes to building solid enterprise applications with Java. Angular has also been revolutionary in building scalable, component-based, user interface applications for the web. So what happens when you combine these two technologies together? In this course you will find out by building a full-stack application with these technologies. We'll be covering Spring Boot, Spring MVC and REST services, Spring data and JPA, Angular components and services, and Angular and Spring Boot app security. By the end of this course you'll have developed a working full-stack application from scratch that spans from the web browser all the way down to the database. To get the most out of this course you'll want to understand the basics about Angular and component-based web UIs and you'll also want to have some knowledge on Spring fundamentals, REST concepts, and persistence layers. If you're new to these concepts this course will help solidify these concepts by doing actual coding with many demos. I hope you'll join me on this coding journey with my course on Building Your First App with Spring Boot in Angular at Pluralsight.

Creating the Spring Boot Project
Introduction
Hey, this is Dan Bunker with Pluralsight. When you're tasked with creating a new project from scratch, you have choices on which piece you should build first. You could start with the user interface or your database or the server code. There's no right or wrong choice. Since this course is about Spring Boot in Angular we're going to start right off with building out the Spring Boot server. We'll then build up the persistence tier followed by tying in an Angular front end. This course will be focused on building out and integrating the entire stack of the project and whether you've been focused on the front end, server side, database or new to it all, you're definitely going to get the chance to learn while doing lots of coding. Let's get started by checking out the app we'll be building throughout this course.

App Walkthrough
You've just been hired as the lead developer for the Globomantics Bike Company and they've tasked you with creating a registry system that can keep track of all of the users' purchases. When a customer purchases a bike from them, they can come to this website and enter their purchase details on this form and complete their bike registration to enable their warranty. I'll quickly fill out the form so you can see the functionality. We can add a buyer name, we can give it an email, phone number. Select the model of bike that you purchased, enter the bike serial number, the purchase price and the purchase date. Once all the information is in you can click Submit. The form clears itself and you see a success message at the top that says the registration has been submitted. So that's the end user portion of the system. There's also an admin section of the system for company employees to see all of the registrations. Employees can access the url /admin and we're prompted with a login. Once the employee enters their credential, they'll get to the admin screen and it will show all of the different bikes that have been registered and you'll notice that my registration is now added down here at the bottom and if I click on that, it takes me to a screen that just shows all of the details for that purchase. Even this app is kind of simple and funny, it contains enough functionality that you can utilize what you learn while building it to apply it to any real-life Angular and Spring Boot app you may need to build. Coming up next we'll get started by looking at how this course will be laid out and the prerequisite pieces that you'll need to have on your computer before we can start building the application.

Course Overview and Expectations
First off, this course is going to be a little different than some of my previous courses. This course is going to be focused almost completely on demos and coding. To get the most out of this course you should plan on coding right along with me each step of the way. With that being said, there are also a lot of concepts and ideas that are involved in Angular and Spring Boot. I'm not going to go in depth on all of these concepts. I want this course to be more of a hands-on course with an emphasis on integrating Angular and Spring Boot together along with a database while coding an application. If you're interested in learning more about some of the concepts that will be covered in this course, you should definitely plan on referencing my Creating Your First Spring Boot Application course in the Pluralsight library and Angular: Getting Started by Deborah Kurata. Many of the other sub-concepts in this course also have existing Pluralsight courses that you can reference and look up such as Spring Data JPA, Java, Angular components, and so on. My recommendation is to keep a notepad by you as you go through this course. If you encounter something that you don't fully understand, simply make a note of it and then look it up later so that you can have that concept sink in and apply it to the coding demos. Next I'll cover the tools that you'll want installed before we start coding.

Spring Boot Prerequisites
This course is basically focused around two technologies. The Spring Boot server and the Angular user interface. I want to take a minute and cover the Spring Boot prerequisites you'll need in order to follow along with the coding demos. I'll cover the Angular dependencies in that portion of the course. First, you're going to need Java JDK installed on your computer and you can find the latest at the oracle.com link, which at this time is 1.9. You may also want to download and install Maven if you want to run the Maven commands from your terminal or command line, but this tool can be optional if you plan on using Spring Tool Suite as your IDE. Spring Tool Suite or STS as it's known, will handle most of your Maven processes and commands and you can find Spring Tool Suite at spring.io/tools. Finally, you might also want a tool like Postman to help you test and try out your REST API endpoints that you'll be building. If you have these tools ready to go, we can get started. Coming up next we'll get a Spring Boot app up and running.

Demo: Creating a Spring Boot App
One of the ways that you can get started with Spring Boot is to use the Spring initializer. You can find that at this URL, which is start.spring.io. This tool lets you configure and select different options and then generate a full project that can be up and running once you import it into your IDE. I'm going to go ahead and create a project and I want to use Maven so I'm going to leave Maven selected. I'm also going to use Java and at this time Spring Boot 2.0 has just been released so we're going to use the latest 2.0 framework and I want to start by configuring the group and the artifact. The group should be com.globomantics and I'm going to change the artifact name to simply be bike. Next, I need to add a dependency that will bring in Spring MVC and the Tomcat server and that dependency is this web dependency that's kind of highlighted in gray here. I'm simply going to type in Web and then I want to select that dependency and that will show down here as a green box as a selected dependency and the last thing I'm going to have to do is just double check that we're using Java version 9 and if I click on this switch to full version link here, I can double check that by going down to this Java version drop-down. It's currently selected at 8 and I'm going to switch that to 9 and at this point I can now generate my project. Before I do though, if you want you can take a look at all of the options by scrolling down that are available to you in the Spring Boot ecosystem, but for now we're simply just going to use the Web one just to get started. So I'll click this and create a project. This will download a zip file onto your computer. All you need to do is extract that and we can head back over to Spring Tool Suite or your IDE preference to import it and get started. In Spring Tool Suite we can import the project by simply right-clicking on the Package Explorer and then the Import option. In the import dialog make sure you select the Maven folder and then click on the Existing Maven Projects option and click Next. At this point you want to browse to the Extracted Bike download from the Spring Initializer. I have the bike template extracted to this portion of my hard drive and I've selected the root of it. I can go ahead and click Open. At this point Spring Tool Suite will notice that it contained a pom.xml file in your project and it brought in the package name and the artifact name that we selected when we create our project. At this point we can click Finish. At this point the Spring Boot app is now imported into STS and we can look at it and most of the information is contained in the source main java as well as the pom.xml file. To start the app I can simply right-click on the BikeApplication.java file and then click Run As Java Application. We can double-click on the Console tab and we'll open up the console. If Spring started correctly you should see that Tomcat is started and running on port 8080. I switched over to the browser and I'm simply going to go to our localhost url and when I request localhost:8080, we get a Whitelabel Error Page. You might think that there's a problem and Spring Boot isn't running correctly, but this actually means Spring Boot is up and running, we just haven't defined any root or home page that it can respond to. That's all it take to create a Spring Boot app. Coming up next we'll start adding some code with a basic model to hold bike information.

Demo: Adding a Basic Model
Now that we have a Spring Boot app up and running, I can start adding some actual code and logic that will make our app our app. So I'm first going to stop the Spring Boot server by clicking the red square here and I'm going to double-click the Console tab so I can go back to my main view. The next thing I want to add to the application is a basic model which will hold bike information so I'm going to create a new package called Models underneath the com.globomantics.bike package. Do that by right-clicking and going to New Package and specifying a models package. In the new models package I can create a new class by right-clicking and saying New Java Class and the class name I'm going to give it is simply Bike. This class is just a plain old Java object class. It doesn't extend from anything. We're simply going to add some attributes to this so we can hold some bike information and later on we'll eventually persist this. So for now I'm going to add the following attributes. We want to add a name, an email, a phone, a model, and a serial number and then we're going to have a purchase price, which will be a BigDecimal, which will handle rounding and decimal pieces and then we'll have a date object for our purchase date and finally a Boolean that says whether we can contact that person or not. Now notice we have some compile errors here. We need to import the BigDecimal and Date objects. So I can do that by running Shift+Command+O on the Mac, or Shift+Ctrl+O on other operating systems. Once you perform that function you'll see that you have two imports up here for the BigDecimal and Date objects. Go ahead and save this class. One tip really quick. I like to turn on line numbers on my code so I can click over here or right-click over here on this gutter and simply select Show Line Numbers. The next thing we need to do is add getters and setters for this class. Spring Tool Suite makes that easy by providing an IDE function. Right-click on the class and go to Source, Generate Getters and Setters. I'm simply going to select all of the attributes to generate getters and setters and then click OK. You'll notice that this added quite a bit of code to our class. The getters and setters simply allow us to access our attributes because they're scoped as private and they can only be accessed through public getters or setters that we placed onto the class. So make sure your bike.java class is saved. That's it for this portion of the course. Coming up next we're going to create a REST controller that will serve out some bike information via an API.

Demo: Creating a REST Controller
Now that we have a basic bike model in place we can start by creating an API endpoint to pass the bike information around. So I'm simply going to clean up the workspace by closing the bike model, and the first thing I want to do is create a new package called controllers underneath the com.globomantics.bike package. We'll do that by right-clicking and saying New Package. Package name will be controllers and click Finish. Inside the controllers package I'm going to simply create a new class and I'm going to call the controller BikesController. Click Finish and we have a new basic controller. So one thing really quick about our application, I've been adding packages like controllers and models. You don't have to do this, but I like to isolate different pieces of my application into different packages so for this application, I'm moving all controllers, all models and so on into their respective packages. The other thing to think about when you're building a REST API, you should build your REST API around a particular resource. In this case our resource is a bike or a bike registration. The name of the controller is often pluralized such as bikes right here, because as we work with a resource we're dealing with multiple bikes on a single or a list-base level. Again, these are just kind of coding standards. If you want a differ or vary it and make it a singular controller, that's totally fine, too. This BikesController is a Spring MVC controller so I need to add a couple of annotations so that Spring will pick it up and process it correctly. The first annotation I'm going to add is called @RestController and the second annotation is going to be @RequestMapping and I'm going to give this controller a base path mapping of /api/v1/bikes. So that is the path or the url that the application will respond to when a request is made. The /api and the /v1 is simply another standard I like to use. By adding versioning to your API you can deal with multiple versions if you need to and API is very clear to the caller that this is a REST API. Those are just my standards. You can vary the url in your apps if you need to and do whatever works best for your needs. The next thing I need to do is import these two classes. I currently have a compiler error right now. I can do that by clicking Shift+Command+O or Shift+Ctrl+O on other operating system if you're not using a Mac and those will bring in the imports that are seen here on lines 3 and 4. The first endpoint I'm going to do is create a list that will return a list of bikes when you call it so I'm going to create a new method in our controller and the method signature will be public List and this is a list collection type in Java and then our Bike object that we created and the method name will be list. We're not passing in any parameters. So again I need to import those two objects so I'm going to go ahead and bring those imports in using my command. The type of list that we want is the java.util.List. Do not use the java.awt.List; that's something completely different. Click Finish and you'll see that list was brought in on line 3 of my file and bike was brought in on line 8 and this is the bike that we created in the previous clip. All that's left to do is simply implement this method now and we'll do that by creating a simple array list and just return the empty list and that code will look like this. So we're using the list interface. We're using generics to type it to bikes, which means we can only hold bikes in that list interface and then I'll set it equal to a new array list and then return that list. So ArrayList has not been imported yet, that's why it's underlined. I'm going to go ahead and import that and save the file and you'll see up here on line 3 now, our ArrayList is imported as well. The last thing I'm going to add to this method is the method level annotation called @GetMapping, which is going to say when a get request is issued to the request base path here, /api/vi/bikes, it will forward it to the list method if it's using the http get verb. Again, that will need to be imported. So this API endpoint returns a list of bikes. I'm going to add two more API endpoints and then we'll discuss what each of them does. The next method I've added is a create method. This will handle form create when the user submits their registration information. It will get processed by this method and then I've created a get method, which will get a particular bike and return that single bike based off of the id that we pass it. So the next thing I'm going to do is to import our missing request body and path variable classes. So I've imported those and finally, I need to add a couple of method-level annotations on the create and this create method will respond to a post to our base URL. That's what the @PostMapping annotation is doing and the response status is simply going to be an OK or the http 200 code. I'm choosing to return 200 here instead of 201, which is created and I've simply done that just to show how you can customize the response status using an annotation. Finally, I've added a @GetMapping to the get method and this is adding on to the base path so it's taking the /api/v1/bikes and it's adding on a /id and the id in curly brackets is saying whatever is passed in on that portion of the url path is going to take that and put into the path variable id parameter for this method. So the last thing I need to do is simply import the missing resources here using my import command, click Save and I have three API endpoints. We can list bikes, we can create a bike, and we can view a specific bike. For now I'm going to leave the create empty and I'm going to simply return a new bike in the get. We'll finish off these methods a little later in the course. For now I just want to get the URL endpoints up and running so that we can test them out, which is coming up next.

Demo: Using the API Endpoint
To test out our endpoints we simply need to start up our Spring Boot server and then make a call to the endpoints. So I'm going to start this new server by clicking on this little Play button up here and that should re-run my previous startup command. We can double check really quickly to make sure that it started by looking for Tomcat port 8080 and I'm going to switch over to the Postman tool. If you haven't ever used Postman before, it's a very simple tool to use. You simply specify the verb that you want to call your API with and then the URL. The URL of our list endpoint is localhost:8080/api/v1/bikes and since this is a get this is going to forward to our list method, which we just created in our bikes controller. We don't need to add any headers or authorization or anything like that. It's wide open and just ready to use. So I can call Send, and you'll notice that we got an empty array back, an empty JSON array. That means that our Spring Boot controller is working. We're simply returning an empty array, which when it comes to JSON is the square brackets. If you didn't get anything back when you sent that request, double check your url and double check that your Spring Boot server is running and that'll be a wrap for this portion of the course.

Summary
In this portion of the course we got a new Spring Boot app up and running. Spring is making this easier and easier over time and here are the steps that we covered. We first created a new app at Spring's start.spring.io website. You simply fill out your app details, select your dependencies, and then click Generate. This downloads the app template onto your computer and you can then extract that and import it into your Spring Tool Suite editor. We then created a plain old Java object of POJO and this POJO is a simple bike class or model that holds the information about bike purchases that we want to register for the Globomantics bike company. Finally, we created a new Spring MVC controller and annotated it with @RestController and @RequestMapping. @RestController tells Spring that all payload communication should be done by JSON by default. Spring relies on the Jackson library to marshal Java objects into and out of JSON. Once the controller was coded up we could test out the API endpoint and that's basically it. We have a running app, which is really a standalone API-based service app and coming up in the next part of this course, we'll tie in the database and get our bike information persisted.

Adding a Persistence Layer
Introduction
Hey, this is Dan Bunker with Pluralsight. At this point the Globomantics bike registry app has been set up and we have a basic bike object that represents the bike purchases from the Globomantics customers. In this portion of the course we'll be turning the basic bike object into a JPA entity that can be persisted to a database. Coming up, you'll learn how to add the appropriate dependencies with Spring Boot, tie in a database, and work with Spring Data JPA in the Spring Boot environment. Once persistence is added, the basic server API portion of the app will be complete so let's go ahead and get started.

Development Game Plan
Before we get back to coding, I want to quickly cover what we'll be doing in this part of the course. We need the ability to save bike registrations and in order to do that we'll need a database. We could pick just about any database out there, but I'm going to use SQLite for this course. SQLite is easy to install and use and supports standard relational database concepts. Once the database is installed, we can then add persistent support to the Spring Boot app. Spring provides a great library called Spring Data JPA that enhances the basic JPA object relational persistence framework. We'll be using this in our application. We can then convert the bike basic java model class that we've already created and turn that into a JPA entity persistable class. The last piece of the persistence puzzle is to add a Spring Data JPA repository and this will act as a data access layer for the bike entity. If you run into any questions or issues on Spring Data JPA, be sure to check out my other course called Getting Started with Spring Data JPA in the Pluralsight library. Finally, we'll want to adjust some of the JSON marshalling the JSON library will do for us when we send our bike entity back to the caller of our API endpoints. This is easy to do via annotations and can help you fully customize how your REST APIs behave with data as it sends objects in and out of the JSON marshalling process. That's it for our game plan in this part of the course. If you're ready to begin, we'll go ahead and get started by creating our database.

Demo: Setting up the Database
Working with the SQLite database is fairly simple because you can use it as a file system database or an in-memory database. To be able to get started with SQLite, you'll want to go to this website sqlite.org, go to the /download.html page and you can download the command line tools for your particular operating system. Once you've installed the command line tools for SQLite, go to the root of your project, which should be in your bike folder where we've created our Spring Boot project and we can add the database there, but before we do we can check to see if we have the right version or the tools installed by simply going to sqlite3 and then just passing in the -version switch. If you get a version reported back, then your SQLite command line tools are installed correctly. To create a new database you simply need to type in the sqlite3 command and give it a file name or a database name. I'm going to call the name bike.db. When you hit Enter it's going to take you into the command prompt for SQLite and you can view some of the tools that are available by typing .help and just to show you that there are no tables currently in here, you can do the .tables command and we currently have no tables. To make creating the table structure easy for this course, I've created an sql folder underneath my ps-spring-boot-and-angular repository on GitHub and you can see that we have a bike.sql file here. If I click on that, we have some commands to create a bike table, create a sequence for that table, and insert some bike registrations into it. So I'm simply going to just click the Raw button so I can copy these commands. I can then go back to my SQLite prompt, enter these commands to create my database. So as long as your back in your SQLite prompt you can paste those commands from that GitHub SQL file and all of those commands should run without error. We can now exit out of the SQLite tool by typing .quit and if we list our directory we should see the new bike.db file inside and as you can see, it's listed there called bike.db. If for some reason you're unable to run those commands or get SQLite installed, I do have a bike.db that you can pull from the GitHub, which was located in the same folder as the bike.sql. You can just copy that into the root of your Spring Boot project. Coming up next we're going to go ahead and get the Spring Data JPA dependency installed now that we have a database to use.

Demo: Adding Persistence Dependencies
Dependency management in Spring Boot is handled in one of two places, depending on which technology you're using. If you're using Maven, it's going to be in the pom.xml file and if you're using gradle it will be in the gradle file. Since I chose to create the project with Maven, I've opened up the pom.xml file located at the root of my folder and I've moved to the dependency section in that XML file. When we first created the app we created a app by pulling in the spring-boot-starter-web. This pulled in Spring MVC and allowed us to create a REST controller in the previous portion of this course. At this point I'm going to add some more dependencies that will handle the persistence layer for our application. I've added three new dependencies starting here on line 32 of my file and the first one is the spring-boot-starter-data-jpa package and this particular dependency brings in the Spring Data JPA library, which is a Spring wrapper and convenience library to work with JPA and JPA repositories. Since we're using SQLite we need to bring in the SQLite JDBC driver and that's what this second dependency is doing here. This is the driver that'll actually handle our connections to and from our SQLite database and the Java code and the last dependency is a dialect helper. This is an underneath-the-covers helper, which deals with Hibernate and JPA, which simply means Hibernate is the provider for the JPA contract or architecture and this SQL dialect will allow us to do things such as create, select, delete, drop, those kinds of things that will need to run against our SQLite database. Once you get these dependencies added to your POM file, go ahead and save the file and Spring Tool Suite should automatically pull those dependencies down after you save the file. Any time you add new dependencies you may want to get your app to force the Maven to update. You can simply do that by right-clicking on the root of the app and going to Maven, Update Project. This will make sure that all the transitive dependencies and the dependencies you selected are properly downloaded and applied to your project. You can check to see if you have any dependency problems by coming down to this Problems tab next to the console and you should have 0 problems at this time and that's it for the dependency addition that actually added quite a few jar files or libraries to our project and this is one of the areas where Spring Boot really shines. Because the Spring Boot parent handles all of your versioning on all of the libraries you pull in, it's going to pull in all the correct versions for the libraries for our persistence layer. Coming up next we'll talk about how to configure our persistence properties and connections.

Demo: Configuring Persistence Properties
Just because we have a SQLite database running and we have the dependencies installed our application still doesn't quite know how to connect the two together. So that's what we'll go ahead and accomplish right now. To do that we want to come to the srcmainresources folder of our application and we'll see that there's an application.properties file. This file is typically used for any kind of configuration in the Spring Boot environment and most of the libraries that Spring Boot integrates with have a lot of customized configurable options. The first three properties that I'm going to add are properties that tell Spring JPA a few things about the database platform we're using. First, we set the dialect to the SQLiteDialect and again, this dialect just says, hey when you're issuing SQL commands, we'll go ahead and do it in the appropriate syntax for the database you've selected and since we've selected SQLite, we're going to use the SQLiteDialect. The next property, which is the hibernate.ddl-auto just allows Hibernate to auto create your model for you. Since we already created the database structure using those SQL commands when we created the database, we don't want Hibernate to generate our model for us and typically in a production environment you always want to set this off because you don't want Hibernate dropping and recreating your database, which could be really bad for production, and finally, I'll set the jpa.show-sql to true just so we can see SQL statements printed to the console when we run the application. These next four properties allow us to connect properly to our database. The first property, which is the datasource.url is the JDBC property connection for the JDBC driver. The driver URLs typically vary and look different from database and for SQLite we simply just define the file name of our database, which is bike.db. This database is completely unsecure. We have no username or password so we're leaving those blank and finally we set the driver-class-name for the JDBC driver, which in the dependency that we pulled in is called org.sqlite.jdbc. Make sure to save that file and that's all the configuring that we need to do. At this point we now can connect our database and our Spring Data JPA ORM to the back end SQLite database. Coming up we'll adjust the bike POJO class we created earlier into a proper JPA entity class. Converting the bike POJO model that we've

Demo: Creating a JPA Entity
created into a JPA entity is not too difficult. We'll first go to the bike model class and open it up, the first thing I want to do is annotate it as an actual entity and I'm going to do that at the class level. That annotation is simply called @Entity and I'm going to go ahead and import it by doing Shift+Command+O on the Mac or Shift+Ctrl+O on other operating systems. If you get a dialog asking which entity to bring in, select the javax.persistence.Entity class as the import. If you remember, we have all of these attributes, which represent a basic bike registration, but as we create an entity for the database we should create a primary key for the object. So at the top of the class I'm going to create a new attribute. The new attribute will be called id, which represents the primary key id for this class and I'm going to set it to the Long data type. I've also added a couple of annotations and these annotations are used by JPA and they simply tell you that this is the id field for the entity and we want to generate it using the GenerationType.AUTO. So at this point these annotations haven't been imported so I'm going to go ahead and import these so we can get rid of the compiler errors and if you're asked what imports to use for the id, it's the javax.persistence id. If you expand your import list, you should see that most of the javax.persistence imports have now been brought in. The last thing I want to do is create a getter and setter for the id so I can do that with the Spring Tool Suite by going to the source, Generate Getters and Setters, and I can select the id and I'm simply just going to put this at the bottom of the file by selecting Last member and then click OK. If we scroll down, you'll see that the new getter and setter has been placed here. If you've worked with JPA before you might say adding a setter for the id is bad because we're auto setting it with a sequence. In this case we do want to create the getter and setter simply because that's how JSON will marshal the id back and forth using the Jackson library, otherwise you would be correct by saying we do not want to set the id typically for a JPA class. At this point if you're familiar with JPA you could go ahead and add column names and column mappings and some of the other information to this, but I'm going to go ahead and leave all this information the same since it will map directly to the database structure that we've created by just attribute name and column name. So make sure your file is saved and that's it for converting the bike POJO to the bike entity, essentially two steps. We classified it as an @Entity and then we created an id for our primary key and now we have an entity class. Coming up next we'll create a JPA repository interface that will be the DAO for this bike.

Demo: Creating a JpaRepository
The JPA repository in Spring Data JPA acts as a data access object or a DAO. I like to place them in their own package so I'm going to do that by right-clicking on com.globomantics.bike package and creating a new package. And I'll simply call it repositories. In the new package I'm going to right-click and create a new interface and this is important to remember. Repositories are interfaces. They define a contract and Spring Data JPA will auto-implement them for us so make sure you select interface and not class when creating these. I'm going to give the interface a name of BikeRepository and I wanted to extend the JPA repository. So I'm going to click Add and search for that and Spring Tool Suite found JPA repository, which is part of the Spring Data JPA library. Go ahead and select that and I can click Finish. My new interface extends the JPA repository and you'll notice that the JPA repository has some generic tying on it and what it wants us to do is replace the generics with the specific DAO object, which is our bike object. So the first type is simply going to be our bike entity and the second type is going to be a Long because the Long is our id and that is the type that our primary key is. So at this point I need to import bike into my import list. I'll go ahead and do that quickly. I now have an import and my interface should compile successfully. The nice thing about Spring data JPA is that when you extend this JPA repository, it brings in a whole bunch of methods for you for the standard persistence. You can create, you can read, you can update, delete, do most of the basic CRUD operations and you don't actually have to implement or write any code to do that. So at this point all that's left to do is we're going to go back over to our controller and swap out the dummy code that we have in there and replace it with the actual JPA repository's persistence code. So going back to the controller, which is in the controllers package, I'm going to open up the BikesController class and the first thing I'm going to do is inject the BikeRepository into the controller. I can do that by using the @Autowired Spring annotation and then I simply give it the BikeRepository type and give the variable a name, which I'm calling bikeRepository. Since we've added some new class dependencies, I'm going to go ahead and import them. That gets rid of the compiler errors and if you look at the import list we've brought in the Autowired import and our BikeRepository interface that we just created. I can now take the injected BikeRepository, which Spring will handle for us and I can replace each of these methods by using the actual persistence code. So for the list method I'm simply going to get rid of the new list and I'm going to call the bikeRepository.findAll, which will find all of the records in our database table and return it and then I can get rid of this other return. The findAll is simply going to do a selectAll on our bike table and again remember we did not actually implement that. That is a free method that Spring Data JPA created for us. The next method I'm going to implement is the get method. This just wants to get a specific bike using the id. If you remember, we just returned a new bike previously, but now that we have the id coming in we can actually ask for the specific id from the database. So I'm going to replace this return new Bike with return bikeRepository.getOne and I'm going to pass in the id from the API endpoint. This will essentially do a selectAll from bike where primary key equals the id passed in. Finally, for the last method, which is the create method, we're going to take the bike information passed in via the API and we want to persist it. We can do that by simply calling bikeRepository.save and pass in the bike object.

Demo: Customizing JSON with Jackson
The last thing we need to do is adjust some of the JSON payload information that will get returned via the Jackson library by going over to the bike model. Because we switched this over to an @Entity, Hibernate which is the basic JPA provider adds some extra implementations onto the class. We want to ignore those implementations so I'm going to go up to the class level and underneath the @Entity annotation I'm going to add the following annotation. The annotation is JsonIgnoreProperties and the two properties we want to ignore are the hibernateLazyInitializer and the handler method, which Hibernate adds automatically to our objects. I'm going to go ahead and import that to get rid of the compiler error and save that. Finally, I'm going to add an annotation to the date attribute and our purchaseDate so that we can pass data for the date back and forth a little easier than the standard date format that JSON provides. So I added the annotation JsonFormat and we're going to just say in the string pattern we want the date to be month-day-year when we're marshalling the date back and forth from this particular field. Again, I'm going to go ahead and import that and save this and at this point all of our code has been essentially coded and ready to test out. So I'm going to go ahead and start the application by clicking on the Play button at the top of the Spring Tool Suite. To make sure that everything started I'm going to double-click the Console tab and I'm just going to look over here to make sure that Tomcat has started on port 8080 and you'll also notice that we have Hibernate Core stuff being loaded as well as the SQLiteDialects and all of the other persistence dependencies and information that we've added so far, and that's it. Go ahead and keep your server running because coming next we're going to test it out using the Postman API tool.

Demo: Using the App with Persistence
In Postman I can now test my API all the way down to the database layer by calling the endpoints. I'll start by listing all of the bikes that we have, set the HTTP verb to GET and I'm calling localhost:8080 to search Spring Boot server and our URL to the bikes is /api/v1/bikes. This endpoint should list all of the bikes in our system. If I click Send you'll notice that we get back the three records that we loaded when we created the SQLite database. I want to get a specific one. I could pass in the id on the endpoint so I can choose from 1, 2, or 3. So if I just say /3 w should just get the Dave Warren record. When I click Send that works. Gets are pretty easy to test, but let's go ahead and test our create. We'll switch that over to a post and we'll back off the /3 so that we're calling the bikes directly; because we changed the HTTP verb, this is now going to call the create method rather than the list method, and since we're posting data we need to specify data on the request body and we can do that by clicking on the Body tab and going to the Raw Radio button and then selecting JSON Application JSON. I'm simply going to pass in some JSON key value pairs that should match up to a few of my model attributes such as the name, the email and the model and I can go ahead and click Send at this point to test it out. If everything worked, you should've got a status of 200, meaning that our create worked correctly and that is the response code that we're sending back from the API. If you prefer to send a 201 instead, you can make that change on the REST controller. Finally, to see if the create worked we can simply call the get bikes API endpoint again, which returns all of our bikes just to see if our new bike has been added to the end of the list. As we scroll down, we can see that down here we have a new bike with an id 4 and we have the John Doe customer and his registration. And that's it for our basic API and persistence portion of the application. If your three API endpoints are working correctly and your data is being persisted and displayed, you have a functional microservice REST API up and running with the Spring Boot architecture and Spring Data JPA persistence for your persistence layer.

Summary
Persistence is an important part of any application and you have options when it comes to building your persistence layer. This application is using Spring Data JPA, which uses the JPA object relational mapping framework, which ultimately runs SQL and communicates with the database, which is a SQLite database. Here's what we did to get all of that set up. Since we're using SQLite as the actual database, that was the first thing that we had to get up and running. Next we added the Spring Data JPA dependency and the database JDBC drivers to the Maven pom.xml file. Once the dependencies were in place, we configured the connections and converted the bike plain old java object model to a bike JPA entity. Because Spring Data JPA utilizes a DAO pattern or a data access object pattern, we then created a JPA repository interface to handle that. Finally, we annotated the bike entity with some Jackson annotations to help customize the JSON payload that the API will ultimately return. At this point we're finished with the server section of the application and between the REST controllers and the persistence layer, there were a lot of technologies at play. Coming up next we're going to make a major switch and dive right in to the front-end Angular portion of the application.

Creating the Angular Project
Introduction
Hey, this is Dan Bunker with Pluralsight. Now that the Spring Boot server app is built up enough to use, we can get started on the front-end user interface portion of our application. The nice thing about Angular and many of the similar JavaScript frameworks is that these apps are highly decoupled from the back end. That means that the Angular portion of this project could have been developed in parallel with the server piece or you could have even started with the Angular project and then built the back-end service later. Regardless, we are finished with the Java coding for a bit so we can take off that hat and put on the JavaScript hat for a little while. To get started, we'll quickly cover what we'll be developing in this section of the course.

Development Game Plan
Since we're switching gears over to JavaScript, I want to take a minute and talk about what we'll be doing. I also want to reiterate that this course is focused on integrating Angular and Spring Boot together with time spent coding rather than time spent covering concepts. If you aren't familiar with something, take the time to investigate and check out the things that you have any questions on and then jump back to this course. The main goal by the end of this module is to have an Angular app up and running and talking to the Spring Boot API server. In order to do that we'll need to install the JavaScript tooling, which will consist of Node and Yarn. We'll then install the Angular command line interface, which will allow us to generate a new Angular app. We can then set up a proxy so that our app can talk to Spring Boot without having to worry about CORS, which is cross-origin resource sharing. Finally, we'll create a service and a component that will allow us to show some data from the Spring Boot bike API. We've got a lot to do so let's go ahead and get started.

Installing and Checking JavaScript Tools
The first tool that you'll need on your machine is Node. Many operating systems now ship with Node and if you don't have Node installed, go here to nodejs.org and download a version that matches your operating system. You also may want to install Node using the Node Version Manager, which you can find from this GitHub repository here, creationix/nvm. NVM just allows you to install multiple versions of Node on your machine at the same time. If you're not familiar with Node, it's simply a JavaScript server and we won't really be using that portion of Node, but we will use the Node Package Manager or NPM, which comes with the Node tool and server. To check to see if you have Node or NPM on your computer, go over to a command line or terminal and simply type npm --version. If you get a version to report back then NPM is installed and working correctly. At the time of this publication I'm using version 5.6.0 of the NPM tool. The next tool you'll want to make sure you have is the Yarn tool. Yarn has been picking up steam lately and is also a package manager like NPM. You can find Yarn at this website, yarpkg.com. Go ahead and follow the instructions on this site to get Yarn installed on your particular operating system. You can check your Yarn tool by typing yarn --version in your terminal and again if you get a version reported back you should be good to go. At this time I'm currently using version 1.3.2. Next, we need to install the Angular CLI tool. This tool is an awesome tool that lets us quickly build a fully working Angular app in just a matter of seconds. To install that tool simply type npm install -g @angular/cli. When the CLI tool finishes you can check to see if it's installed by typing ng -v. If the tool responds with a version then you're set. Finally, we need to tell Angular CLI to use the Yarn tool as the main dependency manager and we can do that by using this command. And that's it. We have all the tooling we need to move on. Coming up next we'll create the Angular UI project.

Demo: Generating an Angular App
The Angular CLI tool is one of my favorite tools, especially when it comes to creating an Angular app and getting started. Before I do that I want to make sure that I navigate to the parent folder of my Spring Boot project that we created in the previous portion of this course. So by listing the directory I can see the bike app that we created previously and I want to make sure I'm in that folder one level above it. For this course I'm going to create the Angular app as a standalone project. There are a few different ways that you can house and deploy the Angular portion of your app, which I'll talk about in an upcoming slide, but for now I'm treating this as a basically standalone app that would go in its own git repository and directory. To create the app you simply need to run the following command. This command will create a new project called bike-ui and it enables the Angular routing module by specifying the --routing switch. You'll most likely always want to include the router in your project if you plan on having multiple pages and any type of complexity. Once the command finishes, navigate into the bike UI and double check that the app was built okay by typing the ng -v command again. At this point the Angular CLI tool should report all of the versions that you're using for Angular. Finally, to start up the app you can use the ng serve or npm start command. Npm start simply runs the same command which is located in the package.json file that was created when we created the application. The last step I'm going to do is I'm going to actually edit some of the default HTML generated by the app. To do that I'm going to use the Atom editor, which you can find at atom.io or you can use any text editor that you like. Once you have your code open in your favorite editor, go to the app.component.html file, which is located in src app. This file has some default HTML that was created for us. I'm simply going to replace it with some HTML of my own. The HTML that I want to add in here simply looks like this. It just has a div with an h1 tag in there, which has a header, which specifies our company name, which is the Globomantics Bike Registry System. I'm going to save that file and I'm going to jump over to a browser. When you start up your server it's going to serve it out on port 4200 so you can type in localhost:4200 in your browser and you should get a page that looks like this that prints out the header that we just added to our HTML. Next, I want to take a second and talk briefly about the different ways that you can set up and deploy your Angular project using a back-end with Spring Boot.

Angular Project and Deployment Options
When you're building a full-stack app with Angular and Spring Boot you have a few options on where projects should be placed and how they'll be deployed. You could set up your Angular client app to sit in the Spring Boot static resources folder where Spring Boot would then serve out the index.html file and your browser could fire up the Angular app and make calls back to Spring Boot for the API resources that it needs. The advantage to doing this is that Spring Boot and Angular are all running on the same domain and port and you don't have to worry about cross-origin requests. The disadvantage is that you typically will tie your Angular app into your Maven build and whenever you need to release anything like a CSS change to your UI, you end up releasing the server app at the same time as well. The other way to go about deploying Angular with Spring Boot is to keep them as separate projects and serve them up separately. This is the strategy I'm taking in this course. This means your front-end and server releases can be completely separate, which makes it nice if you need to change something like a CSS color, you don't need to worry about re-deploying Spring Boot. You do, however, need to use something like Node to deploy and serve your Angular app since you will need to rely on Node to proxy calls to Spring Boot on behalf of your Angular app to overcome the CORS issues. I'm not going to focus too much on the final production deployments in this course, but I am including a Node server js file you can look at on my GitHub repo that you can use to accomplish production deployments when it comes time to doing that. You can find this info in my repository for this course, which is under my profile dlbunker/ps-spring-boot-and-angular and go to the Node folder. There's a README doc in here and a sample server.js file you can use to go forward with. Now that you're aware of a few differences in deployment strategy, coming up next I'm going to set up a local dev proxy that will emulate how a production environment might work.

Demo: Setting up a Development Proxy
To get our new Angular app to talk to Spring Boot correct we need to set up a proxy. The proxy will forward requests from our server running on port 4200 to the Spring Boot server running on port 8080. Proxies are great at overcoming the CORS issues where browsers block JavaScript calls to domains that they weren't served up from. For browsers, this provides a good security measure apps, but it makes it hard to tie js apps to the back ends if they're being served from different servers. Luckily, a proxy file can solve the problem for us. I've created a sample proxy file on my GitHub repo for this course. If you go to the root of this GitHub repo, which is ps-spring-boot-and-angular, there is a proxy folder. Go ahead and click on that and there's a sample proxy.conf.json file. You can either download this file or copy its contents. I'm simply just going to copy the contents and jump back to Atom editor for the Angular app. At the root of your project you're going to want to paste or create that proxy file so I'm going to go ahead and create that file, which is called proxy.conf.json and I'm going to paste in the contents from the GitHub file. This file tells the ng JavaScript server that if it sees any requests that come into it that begin with /server here on line 2 that it should forward them on to localhost:8080, which is defined as the target on line 3. The last change we need to make is to tell the Angular server to use the new proxy. You can do that by opening up package.json and change the following line. In the scripts portion of this file, there is a start command, which happens to be on line 7. I simply want to append the following switch to that command, which is --proxy-config and then I pass in the proxy.conf.json file that we just created. So we can test this out. So make sure that your Spring Boot server is still running. Go over and restart the UI with the npm start command. If your npm start was previously running, go ahead and close that, otherwise go ahead and simply start it again using npm start. At this point you'll notice that we have the --proxy config set when we run that command. You can test out the proxy by switching over to a browser and at your site localhost:4200 we can put in a proxy url over to Spring Boot. The first thing we'll have to do is add the /server. That specifies to the proxy that we are going to forward to Spring Boot. Then we can add a Spring Boot API resource after that, which is api/v1/bikes. If you get a JSON payload back that means your proxy is working correctly and we've got some bikes back from Spring Boot. If not, make sure that your servers are running and check to see if your proxy and url are correct. Coming up next we'll wire up the Angular service and get Angular talking to Spring Boot properly.

Demo: Generating an Angular Service
The Angular CLI tool makes it easy to create pieces of your application. We can use it to create a service. Make sure that you're at the root of your Angular bike UI app in a terminal and run the following command. The command is ng g, which stands for generate, space service, which says we're generating a service, and then following is the name of your service. I like to put everything in a services package so I've defined it as services/bike. You'll see that that created two files for us. One is our actual bike service and the other is a spec test for it. So let's jump back to Atom and we'll add some information to the bike service. Back in Atom you'll notice underneath the src app folder we have a new folder called services and inside of here is our new bike service. We'll jump to that in a minute. Before we can implement anything in there we have to actually add this to our application so Angular knows about that and we'll do that in the app.module.ts file and the first thing we need to do is import this at the top of the file. So we'll import the bike service, specify the path to /services/bike.service. We then need to add it to the providers array, which is located on line 15 in this file and you can simply add the name of the service and save the file. While I'm in this file, I'm going to add another import since we're going to need it for our service and that is the HttpClientModule. So that import looks like this here on line 3. This is a new HttpClientModule that was rewritten in Angular 4 and it is what allows us to talk via HTTP calls to our server back end. The HttpClientModule needs to be added to the imports array so I'm going to add that after the browser module by adding a comma and then the class name. At this point we can jump over the bike service that we created and we're going to need a couple of imports which will allow us to make calls to the back end. The first import is the HttpClient and the other import is the Observable. The HttpClient is responsible for making the calls out and that's going to return an observable, which is like a promise that will come back with the information from the server. To make the HttpClient usable in our code we're simply going to inject it into the BikeService class by adding it to the constructor parameter list and that'll simply just be private http, which is our variable name and it will be of type HttpClient. Next I'm going to create a function in here that will allow us to get all of the bikes from our database. So the service function name will be getBikes, which I can call from a component and it's going to return the payload from this following url, /server/api/v1/bikes. If you remember when we set up the proxy we said that anything that begins with server is going to get proxied over to Spring Boot and then anything on the following path after server will be the path that's used on the Spring Boot server. So essentially we're just going to take the server and we're going to forward on /api/v1/bikes to Spring Boot and that payload, which is a JSON payload, will get returned to this method and returned as an observable. The last piece of code we'll want to the bike service is simply to tell all of the calls that we want to deal with application JSON or JSON payloads and I can do that at the top of this class by adding the following code. You can set up some HTTP options as a constant and in this case we're going to add an HTTP header with the content type of application/json, and that's it for the bike service. It's a fairly simple service at this point. Coming up next, we're going to go ahead and make a call to this service from a new component that we create.

Demo: Generating an Angular Component
Creating a component for our app is as easy as creating the service was. We're going to rely on the Angular CLI tool from the command line. So again, I'm at the root of my Angular client app and I'm going to run the following command. This time when I run the ng g, I'm going to specify component instead of service and then the component name is going to live in the components folder and I'm going to set this up as an admin component. If that ran successfully, you should see a few files generated and at this point we can jump back to Atom editor. You should notice that we see a new folder called components and in the components is our new admin component that we created. Find the admin.component.ts file and open that file up and we'll begin by adding the BikeService import to this class. Imports are always relative to the file you're in so you'll notice we go up two directories, then find the services and go back down to BikeService because we're down two directories in components in admin. Once the import is in place we can inject the BikeService into the admin component by adding to the constructor params list a private bikeService and give it the type of BikeService. Next I'm going to create a public variable to hold all of the bikes that are returned from the back end and I'll simply just call that public bikes. At this point I can now make a call over to the BikeService to retrieve all the bikes and store them in my public bikes variable. So I'll add a new function to do that. Really quickly to describe what's happening in this function we're going to call the bikeService we just created and we'll call the getBikes method, which returns an observable. We'll subscribe to that. We can then either get the data or we'll get an error back and we can log out to the console that our bikes were loaded if we are interested in that. And finally, this method is not going to get called unless we tell the component to call it. Just by defining it doesn't mean that it will get called. We need to tell it how to call that and we can do that in the ngOnInIt function by simply calling this.getBikes. At this point the component should be wired up and ready to display the bikes. The last thing we need to do is update our HTML to actually loop through all of the bikes and display them in HTML format. The HTML is located in admin.component.html and a general basic HTML stub was put in place when we created this component, but we want to replace it with something that will display our bikes. To make it easier so you don't have to type in a bunch of HTML, I'm providing the HTML in the repository for this course, which is ps-spring-boot-and-angular. Jump into the html folder and grab the admin.component.html file and simply copy the contents out of here. Once you've copied the contents, make sure in your editor to replace them with this and save the file. Really quickly, here's what happening. We have a basic HTML table and then we've got this ngFor loop here, which is looping through that public variable bikes that we set up in the component and then we're spitting out some information such as the name, email, model, and the purchase price. At this point we're just about ready to test the UI. We've wired in a component to the service, which talks to the back end through our proxy. The last thing we need to set up is the router so that we can navigate to it correctly from the browser, which we'll do next. Now that we have our components and services in place,

Demo: Setting up the Router
We need to set up the Angular routing portion of the application. When we specified the --routing switch when we created this project, it created this app-routing-module-ts file. By going into that, this specifies the basic route file for the application and this is where your routes will go. This constant on line 4 defines the routes for your application in this array so I'm going to start by creating the admin route. The admin route simply consists of an admin path with the component, which is our admin component we've created and since we've added the admin component to this file we need to import that as well. So I can do that by adding the import line as seen here on line 3. Finally, to finish setting up the router properly you need to make sure that in the app.component.html file we have the router outlet set up. That file is right here. At the bottom of this file we'll specify the router-outlet tag like this and this basically sets up the basic app component as the layout or a template, which means that we'll always have this header here, Globomantics Bike Registry System, for all files or all URLs and each URL or route will then get replaced dynamically in the router-outlet tag and the content that gets replaced in that tag is defined in the app-routing.module file that we created and anything in the admin path coming from the admin component will get put into that outlet tag. At this point we should be able to fire up our application so we'll jump back to the terminal and to start this we just simply need to run the npm start and if you've got all of your ducks lined up and everything's working you should get a Compiled successfully message and we're ready to test this out on the localhost:4200 port of a browser. So if you just go to localhost:4200 you'll get the basic header that it's defined in the app-component.html. To see the admin screen, we need to change the URL to /admin. At this point Angular should have switched over to a new screen and you should see some content displayed here, which is the default content from our SQLite database. If you didn't get any content back, make sure that your Spring Boot server is up and running and that the calls made it correctly over to the server. One way to do that is to simply right-click in Chrome or whatever browser you're using and just inspect the network traffic that happens. If I go to the Network tab and call Refresh, you should see the call to bikes, which is our service that we set up. You can view the response, which should just be the basic JSON payload. You can also preview it to view it in a little prettier format in Chrome, but there's all of our JSON information and here it is displayed in HTML.

Summary
At this point you should have an Angular client that is successfully talking to your Spring Boot application so let's recap what we covered. We first needed to get our computer ready for JavaScript development so we installed Node, NPM, Yarn, and the Angular command line interface. We then generated a new Angular app with the Angular CLI tool and from the command line this is the ng command. Next, I covered the two main ways that you can set up integrating Angular and Spring Boot together. I'm preferring to keep them separate, which requires the use of a proxy. We set up a development proxy to handle calling over to Spring Boot. We then wrapped up with creating an Angular service and an Angular component. We used the Angular CLI tool to help generate those pieces of our app for us and the service makes basic calls to the Spring Boot server for bike info and the component displays the values returned from the service. Finally, we set up the Angular router so that we can actually navigate around in our application and display the appropriate components correctly. If that was your first time doing any Angular development, we did cover an extremely large amount of ground in this portion of the course. Make sure to take some time and let it all sink in. Coming up next we're going to finish off the Angular piece of the project by setting up a form and a few other API calls to our Spring Boot server.

Finishing the Angular Screens
Introduction
Hey, this is Dan Bunker of Pluralsight. Front-end Angular apps definitely have their own ecosystem of tools, concepts and paradigms. We've covered most of that in the previous module and we're now going to finish coding the rest of our missing front-end gaps. This will include creating some Angular components using the Angular CLI tool, finishing off the service calls to the back end, and finally doing some styling of the app to make it look better. Many of the tasks we'll be doing will be very similar to what a front-end engineer would do while working on an application. There's missing functionality to be built so we're going to jump right back into the coding demos.

Demo: Finishing the API Service Calls
I'm in my Atom text editor and the first thing I want to do is I want to finish creating the different services that we have on our server side and match them with services that we're calling from our Angular side. So the service component that we created was underneath the services folder. I'm going to open up the bike.service.ts file and if you remember, we originally added one of the endpoints, which was to retrieve all of the bike listings that we have. When we built out the server though, we had two other endpoints that we created besides this one. One was to view a specific bike and the other one was to post a bike to the server. I created two method definitions. One is the getBike where we pass it an id, we can get back the bike, and the other is createBikeRegistrations. This function takes in a bike object and will post it to the server. Before I implement these functions, take a shot and try it on your own. The getBike will be very similar to the getBikes, but the createBike will use a post on the http object other than the get. Here's the implementation for the getBike. It's essentially the same as this other one, but we're going to append the id onto the end of the path. The createBikeRegistration method is very similar, but instead we're using the post function on the http object and we're calling the appropriate api path, but we also need to pass in the body and an httpOptions. Now the httpOptions were something that we added when we created this service, which essentially sets the content type to the application/json and at this point you'll see that we don't have a body defined yet so we're going to take the bike object that's passed in and convert it to the body and I can do that by adding this line of code. Essentially we're going to take the bike information and we're going to json stringify it so that we can pass it across as the request body. Make sure to save that file and that's it for the bike service. The bike service is fairly simple and as you're making API calls to the back end you'll want to create services like this for all of your API endpoints. Typically they'll be resource based to follow the resource of a properly set-up REST controller or REST API and so you could end up with other services and they would essentially be patterned similar to the services seen here. Coming up next, we're going to go ahead and add a new Angular component that we'll deal with what happens when we go to the home page of our application.

Demo: Adding a Home Component
We've already used the Angular ng tool to create a component and we're going to use that tool again to create a new component for the home page. So make sure you're at the bike-ui root of your application and you'll simply want to use the following command to create a home component. Use the ng tool and specify the g for generate command. We're going to create a component and again I like to place all my components in a subdirectory so I'm using the components directory and then home will be the new component. That'll create four files for us. So we'll go ahead and jump back over to the Atom editor and code this up. I'm going to jump into the components folder and you'll see that we have a new sub folder for home and inside of here are the four new files that the ng tool created. Before I code these up, I'm going to actually add the route for this. So if I go into the app-routing-module.ts file, this is where we set up all of the path routing for our application. The first thing I'm going to do is import the new home component, then I can create a new path for it. I'm going to create a new path right at the top of our constants, which is lines 7 through 10 here and the path is just empty or the root or home page of the application. So when the route goes there, it's going to forward and redirect to the home component. I can now jump back to the home.component.ts file and one of the first things I want to wire up is I want to get the bike service that we just updated imported and usable in our new component. So I'm going to start by importing that at the top of the file and then in the constructor I'm going to just import the BikeService by creating a new private variable called bikeService that I can use with inside the component. Now that the home component is stubbed out, coming up next we'll go ahead and start creating the actual html form.

Demo: Creating and Validating a Form
Since this component represents the home page, the home page of our application is the form that a user fills out to register their bike that they've purchased. So I'm going to create a few attributes at the top of our component that will help us when we start forming and creating the HTML to accept the user input. The three attributes that I've added are simply starting with the models. This is an array of strings, which represent the different bike models that a user can purchase from the Globomantics company. Then I have a bikeform, which is a type of FormGroup. This is an object that allows us to validate forms in the Angular world, and finally I have a validMessage string that we can use to display to the user whether the form was submitted successfully or we had validation or error problems. Since I'm going to be using a form group, I need to import that into the file so I'm going to import that as well as a few other form helpers. So I brought in the FromGroup, the FormControl, the Validators, and those are all found in the @angular/forms section of the Angular framework. Next I can initialize the bikeform object and set some validations up on it inside of the ngOnInIt method or function. Here's what this is going to do. I'm going to create a new FormGroup and inside of the FormGroup I'm going to specify all of the attributes that I want to have on my form and those are going to be set to new form controls. The FormControl takes two parameters. One is the default value for that control. In this case I'm setting them all to empty and the second parameter is a type of validator. So I want to have most of my form controls or attributes on the form required, meaning that the user has to enter them before they can submit the form successfully. If you don't care about any of those things you can set up a new FormControl like this contact here where I pass in no parameters to the FormControl. That mean it's not going to be required and it won't set any kind of default value to it. We can save that component file. At this point I need to add some html to the application. We have a default html component file, but what I want to do is simply replace this with the form component. We could go through and type all that out, but I actually have a helper file on the GitHub repository so I'm going to jump over to a browser and grab the contents of that and then describe what's happening in the html. Hopefully by now you're familiar with the repository for this course and in case you're not, it's located here under my profile dlbunker, and what we want to do is go into the html folder and I have an home.component.html file that you can use as the template for the html we want to paste into our application. So I've clicked on that and you can see that we have a form here. I'm going to simply click on the Raw button, select all of the text and copy it and jump back to Atom to paste this into my file. So in the home.component.html file I'm going to delete that, paste in the content from the GitHub repository and let's quickly go over what's happening here. So first we have a form and you'll notice that we have a formGroup in brackets here that's specifying this is an Angular reactive form and we're using the name bikeform for it. When this form is submitted, the ngSubmit is going to fire and call the method submitRegistration. Now we haven't created the submitRegistration function yet; that'll be coming up in the next clip. The first thing we have in our form starting on line 3 is a validMessage. This will display if we have any kind of message set on the validMessage attribute of our home component. If we do, the curly brackets will essentially take that information and print it out inside of the h3 tag. After that we have all of our attributes and the most important point to look at are the input fields. The input fields simply are creating attributes or inputs for the user to enter and it's going to tie those to the form controls that we set up in our home component. The way that it ties those is through this attribute called formControlName. So the formControlName for this first one is the name, which is the name of the user and that will tie back to our home component's name variable we have right here and we have email, phone, and model, and so on and we see that we have attributes for those, email, phone. Model is slightly different because it's a select, but again it is using a formControlName. It's just the html is a little different because we're using the options of the select to loop through that models array that we created in the home component. So this loop right here, the ngFor that's taking the models, that represents the models set on line 11 here of our component. Eventually we get down to the bottom of the form and we have our submit button and when the submit button is clicked that will fire the submitRegistration message or function that we have set at the top of the form. Coming up next we're going to go ahead and create the submitRegistration and test out our form.

Demo: Submitting a Form
The type of Angular form that we're setting up is a reactive form. Angular provides two form techniques; one is the reactive form, the other is the template-driven form. Both of those are part of the @angular/forms package which we've imported so to make sure that the reactive form is up and running, we need to jump over to the app.module.ts file and import that and set that up as a module declaration. So the import for reactive forms comes from the @angular/forms and it's called ReactiveFormsModule. We can go ahead and just copy that and put that down here in the imports section of the ngModule definition. We can jump back over to the home.component.ts file now and the last thing that we need to do is add that registration submission. Here's the code for the submitRegistration. First, I've made sure that my method name or my function name is the same as the definition over on the form. So in the ngSubmit section of the form declaration our function is called submitRegistration with no parameters. On the home component it's the same name, submitRegistration with no parameters. The first thing that happens is you check for whether the bikeform is valid or not. If the bikeform is valid we can go ahead and set the validation message saying that the registration has been submitted successfully, otherwise we can set an error message saying please fill out the form before submitting and again this validMessage attribute is defined at the top of the component as this validMessage of type string. The next thing I do is I call the bikeService that we just created and updated and we're going to call it the createBikeRegistration. At this point I'm passing in the bikeform that contains all of the values of the user input. That function will call off to the server side and once it's done it will return an observable or a promise. I can subscribe to that and then handle the data or the error appropriately. So if I did get validated back, I'm simply just going to reset the form and this is another function on the bikeform formGroup, or if I get an error I can simply throw that using the observable throw and bubble that back up as an error message. Most of the code inside of this function is workable and we've already imported it with the exception of the observable object. We need to make sure that the observable has been imported. So I'm going to scroll up and do that at the top of the class and that import will look like this and it's coming from the rxjs. At this point we can jump over to the terminal and get our front-end application started up so that we can test it out. Start the app by simply just typing npm start. Assuming you have no compiler errors you can jump over to a browser and we can look at our new form. Again, your application is running on localhost:4200 as the port and you should get a form that looks like this. The interesting thing about this is you should see the models that we set up in the home component and there are our three models. If we try to submit this we're going to hopefully get a validation message. Validation messages say the key saying that we have to fill out all of the form before we can submit. We should be able to put in some data in here and if your server is running, this should actually call the server and submit the data to the server. If everything did submit correctly you will see a new validation message that says your registration has been submitted and the form has been reset. And that's it for setting up a form in Angular. It's not very pretty yet. We'll add some styles to that later, but you have basic user input and submissions to the Spring Boot server.

Demo: Adding a View Registration Component
Now that we have the submit form for the user registration piece in place and we also have a basic admin list view screen, the only piece of the app we have to build left is the viewRegistration component and this is where you can view an actual specific registration from the list on the admin screen, but it could possibly be viewed from perhaps the user itself. So we want to create a new component to handle that. I'm in the terminal at the root of my bike-ui app that we're working on and I want to create a new component like we've done in the past so I'm going to go ahead and run the following command. This time when we run the ng CLI tool we're going to generate a component and we're going to call it components/view-registration. Like before, that's create four files for us and we can jump back over to our editor. I'm back in the Atom editor and you'll notice that we have a new folder underneath the components called view-registration and we have our four new files. Before I start working on those files, the first thing I want to do is set up the routing for this. So again, that is back in the app-routing.module.ts file. I'll click on that and we currently have two paths. We have our home path, which is for the form submission, and we have our admin path, which is for the list piece of the admin screen where we can see all of the registrations. The first thing I need to add is the import statement for our new component and that's going to be import ViewRegistrationComponent and that lives in the components folder view-registration and we're going to find the resolve on the view-registration.component file. Next I can add the actual route and you'll want to be careful when you add new routes because it is most specific to least specific, meaning that if I add a path below and it's a general path, it'll get picked up and used before a previous path. So since this is going to be an admin path, I want to put this before the other admin path. Here's the new path on lines 12 through 15. This path is an admin path right now and we're going to the view subfolder and we're going to view a specific id, which is a dynamic id on this path, which is represented as :id. That means that I can put in any id there and then I can look that up in the component and resolve the specific registration. But since this path contains admin as well as this other path, I want to make sure I put it before the other existing, more generic admin path so that the router can resolve the paths correctly. So I'll go ahead and save this file and next I'm going to go back to the view-registration.component that we just created and that's over here under the view-registration folder and what we'll want to do in this component is we want to get a bike and we want to pull the id off of the route and call the back end to get that specific bike registration so that we can then display it in the html. Since we'll be calling a back-end service I'm going to go ahead and import the bike service and I'm then going to inject that into that constructor so that we can use the bike service at any point in our component. Since the goal is to get a specific bike and view it, I want to add a public attribute to our ViewRegistrationComponent that will hold a specific bike. So I'm just going to call that bikeReg as the variable name. I can now create a getBike function that we can use to call the back-end service to return a specific bike. So I'm going to do that right here and I'm going to call the function name getBikeReg. I'm going to pass in an id, which will be a type of number and then I'm going to call the bikeService that we have generated in the past and we'll call the getBike method on here and this getBike method takes in the id and then returns an observable, observer, subscribe, promise, type, action that we can then do something with the data or deal with an error. So really quickly to refresh our memory I'm going to jump back to the services and look at the bike service and I want to look at the getBike that takes in a parameter, and you'll notice that this just calls our /server/api/v1/bikes/, it passes in the id, which we pass it and it will return the observable promise to us. Once we get the data back, we're just going to go ahead and set that data back on the bikeReg variable that we set here on line 11 and we can now use that anywhere inside of our component. At this point we're almost done, but one piece that we haven't connected yet is how do we get the id off of the route so that we can pass it into the getBikeReg function that we just created. The Angular router makes that easy by providing an activated route object. So I'll go ahead and import that and it looks like this, import activated route and that's coming from the Angular router and what we can do is in the ngOnInIt we'll go ahead and get the current route and then call the getBikeReg id with it and that will look something like this. We're going to call this.route, which we don't have yet. We're going to go ahead and set that in the constructor here in a second. Then we can get the snapshot, which is the latest, the params on there and pull the id off. So this .id is the actual :id route specification that we specified in the app-routing.module.ts file. And the last piece of the puzzle is to get the route injected properly into our component. We'll do that in the constructor. So I'm going to add another param, which sets a variable called route where it will be of type ActivatedRoute. That can then be used down here in the ngOnInIt for this.route. That should take care of our component piece. All we have to do now is update the html, which we'll do in the upcoming clip.

Demo: Finalizing the Last HTML
To help with wrapping up the last of the html for the UI portion of the app I have on the GitHub repository for this course a view-registration.component.html. So again, if you're not familiar with where this is, just go under my profile dlbunker. This is the repository name and you'll want to jump into the html folder, which has this file. So as I click on that, here's all of the html that we're going to want to take and put into our html in the app. So I'm just going to click on the Raw button so I can copy it easily. I can select everything, copy it, and jump back to my Atom editor. Back in Atom I'm making sure to view the view-registration.component html file and I'm going to replace the contents that were generated by the ng CLI tool and I'm going to paste in the content from the GitHub file. So really quick, what this does is this file simply has a link that goes back to the admin screen so once you view a specific registration you can get back to the admin screen and then we go through and print out a bunch of different information about the registration. So it's almost the same thing as the submit form, but it's kind of read-only because you'll notice that we're using divs here instead of inputs to show the bike information. And the last thing we need to do is update the html in our admin html component piece so that we can actually click to link to go into the view-registration.component piece. So I'm going to do that over in the admin component, clicking on the admin.component.html file and on this particular cell of the table where we're printing out the bike name, I'm going to turn that into an a or a link tag so that we can link over to the view-registration.component. That change will look like this. I'm still going to print out the bike name, but that's going to become a link on my a tag and I'm going to use this Angular routerLink so that it's going to the /admin/view and we're passing in the current bike.id. So this bike.id is coming from the loop up here. So each bike will have their own id and we want to pass that in and scope it appropriately. So we'll save the file and we'll go ahead and restart the UI portion from the terminal and then we can test this out in a browser. Again, make sure you're at the root of the bike-ui front-end app portion of the application and you'll simply just want to run npm start and that will get things started. If webpack reports that everything's compiled successfully, we're good to try out the app back on port 4200. Back in the browser I'm going to just go ahead and run localhost:4200 and that should take us to our form registration page, which we've already built. We want to test out the admin side. So I'm going to update the url manually by typing in /admin. Here are all the bikes that I've created and you'll notice that the owner name now is a link. It's not read-only like the rest of this text and that's because we added that router link into the admin html form and this link will take us over to the registration component. And here is the registration component that we just built. All of the html is printing out for this particular buyer called Jeff Miller and again, all of these screens look really ugly because we haven't styled them yet. We'll be doing that coming up soon, but at this point we should have a fully functional app that's talking to the server and printing out all of the html and the bike registrations and the components; everything should be working nicely together. Again, I can try out the other link we added called Back to List and it just takes you back to the admin screen and that is it. So coming up next, we'll go ahead and get some styling on this so the app looks a little better and we'll just be about done with the front-end portion of the Globomantics bike registry system.

Demo: Setting up Project Styles
Just like most things with application development, when it comes to styling you have a lot of options. I will preface this by saying I am certainly not a designer and I am sure that for the designers out there, the UI portion of this interface is going to probably make you sick a little bit, but that's okay. We just want to show that the UI can be styled and how to do that. So I've jumped back over to the terminal and what I'm going to do is just close down the webpack start that we have and I'm going to clear the screen and to help with styling I'm going to use the ever popular Bootstrap to do that and at the time I was recording this the version that worked the best was 4.0.0-beta.2. So I'm going to simply install that using the npm tool and I'm going to do the --save so that it puts it in the package.json file for me. I'm also going to add the @angular-devkit/core npm dependency and that will look like this. I want to use the --save as well and this just provides a set of tools and functions that help out with Angular development and it just makes working with Bootstrap nice. Once those two npm libraries are installed, I can jump back over to the Atom editor. Angular CLI tool generated our app and it created a styles.css file and that file is located underneath the src package or folder. So we can click on that and here is where we can import Bootstrap and add other styling. To import the Bootstrap files you can simply add this line and that's going to go out and grab the bootstrap.min.css file that we just installed with the npm install tool. I'm going to also want to add some custom styling to my application with my own css so I'm going to do that by creating a css folder underneath src and I'm going to add my own css file into that. I'll call this bike.css and again, to make Angular aware of this new css file, I'm going to go back to the styles.css and import this file as well. If you're really good with styling in css you can add any styles to the bike.css file and do whatever you want in there, but for those that don't really care or want to spend the time styling, I have also added a css file that we can import from the GitHub repository for this course. At this point you should be familiar with the GitHub repo. If not, it's located right here and underneath the root we've got a css folder and here is the bike.css contents that we'll want to generate or put into the new bike.css file we created. I'm going to click on the Raw button and just select it all. I don't have a lot in here. You can definitely go crazy with css, but this is just basic styling for the app. Back in Atom I'm just going to go into the css bike.css file that we created and just paste in that content and essentially we're just doing some html height and body padding, some typical h1 stuff, changing some borders and whatnot. Anyway, there's a lot you can do with css obviously, and that's it for styling. All we need to do is restart the Angular portion and we can test out the application. Back in the terminal I'm simply just going to run npm start. Oops! You'll notice that I got an error here and sometimes this happens when you're working with JavaScript and Angular. It's because the Node_module stuff sometimes gets messed up so the easiest way to fix problems like this if you're having any type of problems with running the JavaScript is to simply run npm install again to help clean things up. So I'm going to do that and that will take all of the dependencies in your package.json and just make sure that they're down and running in your particular application subfolder. Once that finishes we can then try the npm start again. Alright, webpack has compiled successfully so we can jump back to the browser and see our new styling. So I'm in the browser and where I left off last was on the admin page. So I'll go ahead and just refresh from here and you'll notice that we've got our background gradient. We've got different text font. We have our tables looking a little better. If we go in and click on one of these now, we've got the form controls coming across, which is out of the Bootstrap framework and finally we can go back to our home page and see if our submit form looks a little better with styling. And that's it. That's all it takes to style. If you go back and make changes to any of the styles or pieces, you'll get that reflected because we're using the live reload with the Angular CLI tool and at this point you pretty much have a full-stack Angular app talking to a Spring Boot server with a database on the back end.

Demo: Creating a Production Build
So far we've been developing in a development environment. I want to take a minute and talk about what it will take to get Node and Angular running in a production environment that's still talking to a Spring Boot server. So on my GitHub repo for this course, there is a node folder. If you click on that there's a server.js file, which we're going to want to copy onto our system. There's also a README here for some more instructions on how to do this if you want to look at that in more depth, but if you click on this, this is a basic Node express server that will serve out the Angular app and then do a proxy redirect over to the Spring Boot server. So you could run this, for example, on Heroku or say Digital Ocean and still have it talk to Spring Boot server on the back end, but run in a production build environment. So to set this up I'm simply going to copy the contents of this file and jump back over to Atom. At the root of my bike-ui folder, I'm going to create a new file called server.js and paste in the contents from GitHub. Really quickly you'll see that it's using dependencies up here at the top. We're using Express and a few other things. Then down here is where it gets interesting. Right here we're using a app.use where we're proxying over to server and this is really no different than the proxy.conf.json file that we set up for the dev. We're just going to do it for prod, but really the big difference between prod and dev is down here where we send back the index.html. So before we can run this we have to import a few of the dependencies at the top and then we have to do a production build so that this index.html is generated and we can run it as a Node service. Back in the terminal I'm at the bike-ui folder of my application and I want to install some of those Node in Express dependencies. So I can do that by running this command, which will install the express-http-proxy and bring in Express as well as a transitive dependency. I'm also going to install the cors dependency and the port dependency. To do the production build I'm going to use the Angular CLI tool to do that. So that's the ng command. I'm then going to issue a build and I'm going to pass in --prod, which means go ahead and package and build this for production. Now that that's finished, I'm simply going to clear the screen just to make it a little cleaner and at this point I can simply run the node server, which would be like running our dev server, but it's going to use the production index.html build. So to run that I'm simply going to type node server.js. If you get a print statement saying the API is running on port 4200, that means that everything is working and we can go back to the browser and test that out. I just chose to use the same port as the development environment, which is 4200, but if you wanted to set it to port 80 or 443 for SSL or 8080 or whatever you wanted, you could go ahead and make that change in the server.js file. Just refresh this and you can see that our app is still working. So that's all that it really takes to get your app up and running for a production build. It's not too different from dev, but you do need to have that server.js piece in place and get the proxy set up correctly to your Spring Boot server.

Summary
This part of the course consisted of wrapping up the loose ends of the Angular portion of the course and again, we covered a lot of ground so make sure that if you have questions on anything that was done that you spend time researching and understanding those concepts. We started out by finishing the API calls to the Spring Boot server by adding some service calls to the bike.service file. Once that was in place we could then create the home component that would accept the user registration via an html form. This was a little different because we needed to accept user input, do a validation and handle posting the contents back to Spring Boot. We then added another component to handle viewing a specific registration and tied that into the admin list screen. To make everything start to look a little more pleasant, we then added some Bootstrap and some of our own custom styling to the application. And finally, we went over how to run Angular in a production environment by using a Node Express server and running the production build using the Angular CLI Build Tool. Coming up next, we'll dive deeper into our application by adding security to the server and the front end.

Securing the Application
Introduction
Hey, this is Dan Bunker with Pluralsight. Now that we have a fairly functional application, it's time to think about security. Most real-world applications will need security of some sort. Security is such a wide and broad topic though, that you could easily have several courses just on security with a particular technology like Spring or Angular. Since this course is focused on getting a fully functional Spring in Angular application up and running, I'm definitely going to take an opinionated approach to securing it. There are many frameworks, patterns, and concepts that could be used, but I want to focus just on how to add token-based security to an API and an Angular client. To get started I'm going to cover how security and tokens will work with our existing app.

Security Overview
Any application that wants to add security will need to deal with two concepts. Authentication and authorization. Authentication is concerned with identifying a user and verifying that the user really is who they say they are. This is usually done by presenting a login screen where the user can enter credentials such as a username and password. If the credentials presented pass verification then authentication has succeeded. We could build our own authentication service, but that would be out of scope for this course so for this piece we'll be utilizing Auth0, which is a security-based service that will perform the authentication mechanism for our application. This will use the OAuth security paradigm. Once a user has been authenticated, a temporary unique token will be issued. This token can check back with the Auth0 server at any time to determine if the token is valid or not. If it is valid then whoever possesses that token has access to the system. For our application, that means once a user has authenticated, the Angular app will store the access token and present it to the Spring Boot server when our API call is made. Spring Boot can then ask Auth0 if it's valid. If so, API access is granted, otherwise a 401 unauthorized response will be returned. This is our basic security token pattern we'll be implementing. Coming up next, we'll get started by creating an Auth0 account.

Demo: Creating an Auth0 Account
Creating an Auth0 account is quite easy and it should only take a couple of minutes, but we want to start by going to the url auth0.com and you should get a home page similar to this. We'll begin by going over here in the right-hand side and clicking on the Sign Up button. To sign up you can either use an email password combination or connect it to GitHub, Google, or your Microsoft account. I'm going to start by entering my email. I can then click on the Sign Up button. The next step on the signup process, you'll want to enter your tenant name and select your region. For the tenant name you can choose whatever name you want. I'm going to use something similar to my email address and select US region since that's where I'm at and then click Next. The last step is you just need to specify some information about your account type and I'm going to go ahead and select the Personal. I'm going to be the role of Developer and for a project I'm just going to say we're playing around and I can create the account. After your account is created you'll be taken to the dashboard. One last step that you'll need to do is go over to your email client and find the email that Auth0 sent you and open it and verify your email address so that your account can continue to be used. Once that's done you can then go over to the APIs section of Auth0, which is on the left-hand side here and click on that and we can begin by creating a new API from this button. When you create a new API you simply need to give it a name so I'm going to use bikereg as the API name and the identifier is typically your url. Since this isn't a deployed app yet, I'm going to use the localhost version. Localhost:8080 refers to the Spring Boot API portion of the application and I'll go ahead and leave RS256 selected for the Signing Algorithm and I can click Create. Once the API is created, you'll see a bunch of information that Auth0 gives you. We'll go ahead and ignore that for the time being and we'll jump over to the Scopes tab and inside of the Scopes tab this allows us to identify different pieces of the application that we want to add scope or access to. So we have two pieces. We have the admin list and we have a specific bike registration on the admin list. So we'll create a scope for each of those sections. The first one will be called view:registrations, registrations with an s that is, and that will be the admin list. The second one will be viewregistration singular, which will be a specific registration. Now that we have both of our scopes in place for our application that gives us enough to head back over to Spring Boot to start adding the authentication pieces, which we'll go ahead and do next.

Demo: Adding Security Dependencies
I'm back in the STS tool and I'm looking at my Spring Boot application and I'm going to start by opening up the pom.xml and jumping over to the pom.xml tab. I want to begin by adding a new dependency to the dependency section so I'm scrolling down and I'm going to add a new Auth0 dependency. The new dependency is going to have a group id of com.auth0 and the artifact id is auth0-spring-security-api and the current release version at this time is 1.0.0-rc.3 I'll go ahead and save this and STS will go ahead and pull in that dependency into my project. Once the dependency is added, I want to go over to my application properties, which in src main resources and open up that file. If you remember, this is where we added our persistence connection information. I'm going to go ahead and add a couple other properties for security now and they will look like this. The two new properties are auth0.issuer and the issuer is essentially your tenant name with auth0.com and your API audience is the identifier that we added for our API and save that, and just to show you where this information is coming from I'm going to jump back to the Auth0 dashboard to see where you can find your particular values. On the dashboard if you go to your APIs section you'll see that we have two entries here. We have the Auth0ManagementAPI and then the bikereg API, which we added. If you look at the API audience you'll see that it begins with https://danbunkerps.auth0.com. That is your issuer and that is the value that you'll want to put in for your particular entry into the application.properties. So you'll most likely have a different name here since you can't choose the same tenant name that I have and then the API Audience down here for the bikereg, this value is the value that we set in the audience. And again, those two values are set here. So make sure that file is saved and that's it for getting the dependencies and the configuration setup for Auth0. Coming up next we'll add the Spring security configuration piece so that we can talk and secure things correctly using the Auth0 API.

Demo: Setting up Spring Security Configuration
To properly finish securing the Spring Boot site we need to add a Spring Boot configuration file. I like to add Spring Boot configuration files in their own package so I'm going to create one underneath our com.globomantics.bike package and I'm going to call the package config and then I want to create a new class inside of this new package called SecurityConfiguration. Since there is quite a bit of configuration we'll be adding, I've created this class out in my GitHub repo so I'm going to jump over there so we can grab that content. So on the repository for this course, which is under my profile dlbunker, find the java subfolder and click on that and you should see the SecurityConfiguration.java file. I'm simply going to click on the Raw button so I can just cut and paste this. So I'm going to select all of the information and jump back to the STS code. So back in my IDE I'm simply just going to remove everything that was currently generated in there and paste in everything from GitHub. Click Save and we'll just double check that there aren't any compilation errors. I want to talk about what this does. So I'm going to double-click on this tab so that we can view all of the code a little easier. So a couple of things at the top of the class. The class annotation @Configuration tells it, Spring Boot, that this is a configuration class and should be run when the container is started so that any configuration can occur at that time. The @EnableWebSecurity is another Spring Boot tab that is saying, go ahead and enable security for the application and anything defined in the class down below is how we'll secure the application. On lines 15 and 17 here you'll notice that we're injecting a couple of values and it's the auth0.apiAudience and the auth0.issuer. These were the two values that we added to our application.properties file. We're going to go ahead and inject that value into this and those will get stored in these two strings located here. The bulk of the security though actually happens in this configure block and what's going on here is we're using the RS256 issuer and apiAudience signing that we set up when we created the bike @apiRegistration and we're using JWT or jots which is issued from the Auth0 server. The rest of this just says for any HTTP requests, go ahead and authorize the requests and here are the APIs that we have for our application and you'll notice the two or three information pieces at the end of here that are important is when we post or create a new API, that's kind of the public endpoint. So we want to permit all traffic on there, meaning that they don't need to have an API token, but the get for the bikes and the specific bike needs authentication because those are our admin screens and so this has authority. It's passing in a couple params and those should look familiar because those are the same scopes that we added when we created our API in the Auth0 dashboard. So the first one is the view:registrations, which is our admin list, and the other one is view:registration, which is a specific bike registration and that should be it to get our Spring Boot secure application up and running. You'll notice that if you're ever working with Spring security you're going to be working with the security configuration file and you can pretty much end up doing anything. There are all sorts of examples out there, but I wanted to keep this simple just so you could see that we're restricting API access via these antMatcher patterns here and URLs. So the last thing I'm going to do is I'm just going to double-click this and go back to the main app view and I'm going to start up the server and we can test to make sure that these endpoints are secure now. Once your application is started, jump back to Postman and here we can test if security is working by calling a get to our api/v1/bikes, which is the admin list of our application. So if I simply send a request in, you'll notice that the status came back as 401 unauthorized because we haven't sent a valid token to the back-end server and that ultimately means that security is working. Coming up next we're going to jump over to the front end and start working on securing that portion.

Demo: Configuring an Auth0 Client
To get started with configuring security for our front-end piece of the application we need to go back to the Auth0 website and go to the dashboard and you'll see that there is a client section in the left-hand menu. Go ahead and click that and we created our bike API and it also created a non-interactive bikereg client, which we can use to authenticate our client. So I'm simply going to select that and go into the details and there's a bunch of information in here about the client. I want to go down and find the information about the callback URL. So on the client page there should be an Allowed Callback URLs box and inside of there I'm going to add the following callback URL. This is going to point to localhost:4200 and that is the Angular port and application for the bike registry and then I'm going to call the URL on that Angular application as /callback. Scroll to the bottom and save those changes and we can now go ahead and install the Auth0 JS dependency. So we'll jump over to a command line or terminal for that. Auth0 also provides a JS library for use in an application such as Angular or React so I'm going to go ahead and install that using npm. That'll be npm install and I want to --save that to the package.json area and the npm package is auth0-js. Once we've configured the auth0.js and the Auth0 dashboard for the client, we can go ahead and start adding the callback component for our Angular application, which we'll do next.

Demo: Creating a Callback Component
Now that we've set up the callback in the Auth0 dashboard, we need to create that callback component in Angular and all the callback is going to do is once we've authenticated with Auth0 it needs to know where to call into the application on a successful authentication. So that's what this component is going to do is we're going to set up that callback that will happen from Auth0. So again, I'm back at my terminal at the root of my Angular portion of the application, which is bike-ui and I'm going to create a new component using the Angular CLI tool. It'll look like this. We're going to use the ng g, which is for generate, space component because we want to create a component, and the component will live in the components folder and we'll call it callback. Once that's done you should have a few files that were created and we'll go ahead and jump back to the editor for Angular. I'm back in the Atom editor and I'm going to open up the src folder of the application, go into app and components, which is where our new callback component is, and I want to start by editing the html, which is in the callback.component.html. So I'm going to remove the default generated html and I'm going to replace it with this. I'm simply going to create a new div and inside of there a paragraph tag that just tells you that you're logging in and to hang tight. I'm going to save that file and now I need to create a route to handle the callback. So again, that's in the app-routing-module.ts file. So I'm going to go over there and I'm going to begin by importing the new callback component. Next I can add a route for that and that route will look like this. The path is going to be callback and that path matches the url callback that we set up in the Auth0 dashboard and the callback component will go ahead and handle that route. Go ahead and save that file. At this point we have our basic callback component and route set up to handle callbacks from Auth0. Next we need to set up and authorization service that can handle what happens once we get a callback. So we'll be doing that in the next section.

Demo: Creating an Authorization Service
We now need to create an Angular authorization service that we can use to deal with authentications as they come back from Auth0. Once the callback is made, we need to store the token that is passed to us so that we can later pass it to the API calls, which ultimately Spring Boot will handle and check with Auth0 on its site. In the past we created a service using the Angular CLI tool. I'm going to do something a little bit different with this. We're going to create a service just manually because you don't always have to use the Angular CLI tool if you don't want to. So in our Angular portion of the application, go to src app and open up the service folder and we already have a bike.service with a bike.service.spec test and we're just going to create a new file in here and we're going to call it auth.service. If I wanted to add a test to this, I could also do that, but we're not really focused on testing in this course. We just want to work on functionality. So we have our auth.service file ready to go. Now there is quite a bit of code in here so again I've created this file for use out on my GitHub repository so I'm going to jump over there and grab the contents and we'll talk about what it does. I'm back a GitHub and I'm in the repository for this course. I'm going to go into the js folder and you'll see that there's an auth.service.ts file. If we go in and look at it I'm going to go to the Raw contents and simply copy those contents and place them inside of our new auth.service file. I'm back in the Atom editor and in my auth.service file I'm going to paste the contents from GitHub and the first thing that you're going to need to do is replace the code on lines 10 and 11 with the particular id and domain from your Auth0 account. So I'm going to save this file and go over to Auth0's dashboard to show you where to get this information. From the Auth0 dashboard simply go to the Clients area where we set up our previous client, which is this bikereg here. I'm going to click on it to go into the details and you'll see that one of the values down here in this grayed-out box is the Client ID. So this is one of the things that we're going to want to copy into our application and then you'll also notice the domain. So I'm going to start by copying the client id. You'll want to paste your value into the clientID position and I'll go back and grab the domain. Domain is this value here and copy that, but before I leave, I want to make one small change to the client just to help out with the type of application we're developing. So down here we have a Client Type and right now it's set to Non-Interactive Client. I'm going to choose a Single Page Application because that is the type of application that Angular is. Come down to the bottom and save those changes and now I can head back over and paste in the domain into my code. Back in Atom I can simply replace the YOUR_DOMAIN with the specific domain from Auth0 and save that file. We'll talk a little bit about what this class is going to do. So we have an auth0 initialization block at the top here, which pretty much takes the Auth0 configuration from the Auth0 dashboard. So we have our clientID and the domain id. Then we also have the audience, which we set up for the API, and we have our redirectUri. That's the callback uri that we set on our client and then we also have the scopes that we're allowed to use and pretty much we're going to ask for access to the view:registration and the view:registrations scopes that we set up when we created the API in Auth0. Up here on line 4 you'll notice that we're importing everything from the auth0-js library and that was the library that we installed with the npm tool a few clips back. If you want to fire off a login programmatically, this method or function here on line 20 can handle that, but the real method that we're interested in is what happens when they come back from Auth0 and that's this handleAuthentication piece. Once the authentication comes back from Auth0 we essentially have our accessToken and we want to store that token and do a route after we get the token. So we're going to set the token in the setSession function and then we're going to use the Angular router to navigate to the admin screen. Now really quickly, all the session is going to do is pull off the accessToken, the idToken, and the expiresAt values for the token given to us from Auth0 and we're going to store that in the local storage of the browser. You could put this in a cookie or use another type of storage system to hold on to the token, but I just chose to use localstorage since it's pretty simple and we can access it and remove from it fairly quickly. So likewise if you need to log out you can call this logout function and all it does is simply remove the access_token, the id_token, and the expires_at from local storage and then we'll no longer be passing those tokens across to our API calls and we should get 401s. And again here is another helpful method just to determine if you're currently authenticated or not. You can do this and all it's doing is just checking the expires_at. If it expires then we would want to go ahead and ask for a new login and token from Auth0. Since we added a new service to our Angular app, we now also need to import it into the app-module so I'm going to go to the app-module file, click on that and we can go ahead and import that. So I'll start by importing it up here in the import list. We'll want to import the AuthService and then we'll want to take the AuthService and add it to our providers and that can be done by adding it to the array here on line 29 of my file. We'll save that file and we currently have a new Angular service, which handles our authentication piece and it's ready to be used. Coming up next, we'll go ahead and add the AuthService that we just created to our code so that it actually handles the authentication from Auth0.

Demo: Setting up the Authentication Callback
To finish setting up the authentication callback we next need to set up the application so that it hooks into our handle authentication function that we created and we should be set for that piece. So the file that I'm going to add that to is just the basic app.component or kind of where the application gets started for the Angular app and that's in the app.component.ts file. So the first thing I'm going to do is import the AuthService that we just created. I can then inject that into this class via the constructor and inside of the constructor I can call the authService handleAuthentication and it will go ahead and deal with the authentication success callbacks. Alright, I've saved that file and that kind of handles the authentication piece, but if you remember early in this portion of the course we have to deal with two type of security. We need to deal with the authentication and the authorization. So now that we've handled the login via the Auth0 screens and dashboard and we're handling the authentication callback in our Angular app now, we need to worry a little bit about how to secure down our routes or the secure portions of the application. So coming up next, we'll go ahead and add that to our application.

Demo: Securing Angular Routes
To protect the routes I'm going to go ahead and create another service and I'm just going to do this manually in the application. In the services folder I'm going to create a new file. I'm going to call that file auth.gard.ts. I'm going to create a class in that file called AuthGuard and it's going to implement the CanActivate. The CanActivate is a piece from the Angular router that tells whether you can activate that route or not. So since I'm using the CanActivate, I need to import that. So I'm going to do that first and that comes from the Angular router. Next I want to make the AuthGuard injectable so I'm going to add that at the top of the class @Injectable and because I added a new reference I'm going to have to add that import as well and the injectable comes from the Angular core and that import looks like this. The function of this class is going to be to determine whether we're authenticated or not and if you remember in our AuthService we created the isAuthenticated function and so we want to utilize that function to determine if we're authenticated or not. So I'm going to go ahead and import the AuthService as well and that would be line 3 of this file and once I have the AuthService imported I can go ahead and inject it into the AuthGuard class by using a constructor and setting the private authService to an instance of AuthService. The CanActivate from the Angular router acts as kind of a command pattern where once you implement the CanActivate function it will fire that for you when the router gets called so I'm going to create a new function to handle that called CanActivate and it's simply going to do a couple of things. It's going to check to see if we're authenticated by calling the AuthService and checking the isAuthenticated method, which just simply says hey, if the token is expired then we're not authenticated; otherwise if it hasn't expired, we're good and we can go ahead and make the call to the router. If we aren't authenticated we then use the authService login function to fire off the login to the Auth0 UI screen to gather the credentials from the user. So go ahead and save that file and at this point we need to jump back over to the app-routing.module where we can add this to the routes that we want to make secure. So again, that's in the app-routing.module.ts file so I'll click on that and head over there. The first thing I'm going to do in the file is simply import the AuthGuard class that we just created and if we look at the routes that we have, we have the home route where a user can enter a bike registration. We have our two admin routes and then we have the callback route. So the two routes that we're specifically interested in securing are the admin paths. So to secure those paths all you simply need to do is add another hash value so the canActivate key is going to use the AuthGuard for the admin view and we'll add that as well to just the blank admin path. So what this means is when the router goes to these particular paths or URL routes, it's going to make sure that it passes the canActivate AuthGuard's canActivate function and that function just checks to see if the AuthService is authenticated, which ultimately just checks to see if our expired token has expired or not. And finally we need to add the AuthGuard to our module for Angular so I'll come back to the app-module.ts file and we can add that in here. So begin by importing it and I can then take the AuthGuard class and add it as our third and last provider for the application and save that file and we're just about done by adding security at the front end. If you'll notice, we're adding a lot more security pieces to the Angular side than the Spring Boot side and that's because we're trying to get everything lined up so that we can get that token passed back to the Spring Boot server correctly and so coming up next we're going to add that last piece in, which is getting the token passed on our http calls.

Demo: Passing the Bearer Token
To pass the authorization token over to Spring Boot we need to go to the area in our application that does the http calls to the back end and so that's done in the services folder and we do that in the bike.service.ts. Inside of here we have our three back-end calls. We have the getBikes, the getBike with a specific id, and the createBikeRegistration. The createBikeRegistration is our public route so we don't want to do anything to that. We are more concerned about securing the admin portions, which are the getBikes and the getBike that takes in an id. So if you remember, this is using the http client, which is coming from the @angular/common/http package and so if you want to secure this, we need to pass in the headers that pass in the token. There are a couple ways you can do this. You can do it manually, which we're going to do here or you could also sub-class or override the HttpClient and add this manually for all of your get, post and delete calls that you want secured. So to add the token manually I'm simply going to get the token from the local storage because that's where we stored it and we stored it as the access_token and we then want to pass that token in as an http header. So on the http.get call, the first parameter is typically the path or the url and the second parameter, which I'm going to add, will be the headers for that http call and that header param looks like this. We're passing it in a curly bracket or some object hash values. The key is going to be headers and we're going to create a new HttpHeaders and we're going to set the Authorization header equal to Bearer, space, the token value. This is a common http header authorization scheme for use with APIs and tokens so regardless of the authentication and authorization service that you're using, you'll often see this passed in on APIs specifying the token that is used to access the back-end API. I'm going to update the other function with the similar manual process so I simply grab the token to get down to localStorage and pass it in as a header. It's the second param to the get. I can save this file and again, I'm kind of starting to duplicate code here. This isn't great for many enterprise production code, but it's simple and we don't have to actually subclass or create the http client which could do this automatically for us for each of the get calls. So if you're planning on doing this for a lot of API calls, make sure that you refactor and pull this header generation and Authorization Bearer creation into a common one set piece of code. And that's it. We've added all of the different pieces and we've done a lot here so we need to keep our fingers crossed to make sure everything is working. We've got all of our ducks lined up in a row and we'll go ahead and test out the application coming up next.

Demo: Running the Final App
We finally reached the point in time, it's time to fire up our application and see if everything is working and we have security in place. Hopefully your Spring Boot server is still running and if it's not, make sure you jump over to your Spring Tool Suite and start up the Spring Boot server. I'm currently in the bike-ui of the terminal and I'm going to start that up using the npm start command and this will fire up the Angular portion of the application. Okay, if you get webpack stating that it's compiled successfully, this is actually a really good sign because we did a fair amount of coding in our Angular piece so that means that at least we don't have any compilation errors so we'll go ahead and jump over to the browser and test this out. In my browser I'm going to go to just the basic localhost:4200 page just to make sure my non-secure public route still works, which is the form that accepts a user registration. So it looks like that still works. I'm not going to go ahead and submit a form at this time. I want to go over to the admin screen and see if we can get a security login. Since we don't have a navigation or a button to do that from the UI, I'm just going to type in the URL manually by going to /admin. At this point you should've gotten redirected over to the Auth0 login screen and that should show the bikereg test client that we set up from the Auth0 dashboard. Since we haven't created any test client usernames or passwords, let me go ahead and sign up for one and I'm just going to use my same email and password that I used for the account creation. If you want to use a different email, that's fine too, just go ahead and pick one and then click Sign Up. You're then taken to an Authorize App section. So this is part of the OAuth spec and paradigm meaning that before we can get called back to our application the user has to authorize access for this application. So you'll notice here that we're also getting scope access information so these are the two scopes that we set up when we created the bike API in Auth0 saying that this application is going to view your registration and view a specific registration. You'll notice that it also accepts the tenant and the username that we just signed up with. So I'm going to go ahead and say, okay, we'll accept this and authorize the app by clicking the green checkbox, and at this point you should have your admin screen, meaning that we got in and we are secured. We should also be able to view a specific registration by clicking on that and at this point we don't have to go back to the Auth0. Because we have a valid token we are essentially given access to our system from this point on. If you want to view that token you can right-click in Chrome or whatever browser you're using and go to the Inspect. You'll want to look at the network traffic for this. I'm just going to go ahead and refresh this so we get the network traffic on the graph here and you'll want to find the call to the back end so here's the server api/v1/bikes. If you click on this you can see the response, but we want to look at the headers that were sent out. Clicking on the Headers tab we can scroll down to the Request Headers. These are the headers that we sent out and you'll notice that we have this Authorization Bearer with this really big ugly, kind of unique number and that is our access token that Auth0 provided us. So this token is the token that secures the application. These tokens typically expire after a certain amount of time. That's why you'll have to re-log back in and these tokens can be revoked by the Auth0 authorization service so that if somebody, for example, steals this token and is doing something with it, you could revoke it so that it's no longer useful. If you were to go back and look at the home page of the application, you'll notice that we're not passing in this Authorization Bearer token on the header because we're not securing that particular part of the UI. We're only doing this on the admin screens because that's where we did the token check in our bike.services.ts file, and that's it. We have now secured our application and we're good to go. Coming up next we'll summarize everything that we talked about so far in this particular section of the course and go from there.

Summary
And that's it for this course. Congratulations on sticking through all of the coding and concepts that were covered. We've gone from nothing to a fully functional, secured application. Here's what we covered in this portion of the course on security. We needed an authentication service so we began by creating an Auth0 account. This allowed us to set up an OAuth secured app. If you're working for a large corporation you most likely will build this piece on your own and not use a third-party provider like Auth0. We then added security support to the Spring Boot server by adding the security dependencies and configuration needed so that we can receive and check tokens with Auth0. Next we added the Angular client security dependencies and configuration and once all of that was in place we could then create our security callback component and set up the authorization service so that we can initiate logins to Auth0 and receive notifications once the login has succeeded, which is known as the callback. Finally, we needed to secure the admin portion of the application and make sure that the secure API endpoint calls pass the bearer token so Spring Boot would grant access to that part of the API. We did that by creating the AuthGuard and by passing in the Authorization Bearer on our API calls. Thanks for taking the time out of your schedule to watch this course. I hope you were able to learn a few things about Spring Boot and Angular and you have enough confidence to now start tackling your own personal projects with these technologies.